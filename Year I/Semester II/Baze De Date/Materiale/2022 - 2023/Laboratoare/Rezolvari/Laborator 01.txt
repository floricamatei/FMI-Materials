-- LABORATOR 1 - SAPTAMANA 2

-- EX 5
-- cu duplicate
SELECT JOB_ID
FROM EMPLOYEES; -- 107 rezultate
                -- fiecare angajat are un job asociat
                -- avem joburi la care lucreaza angajatii
                -- in EMPLOYEES, JOB_ID este cheie externa, ceea ce inseamna ca se poate repeta
                -- si poate fi chiar si NULL
                -- in cazul diagramei noastre, nu este NULL (toti angajatii au joburi)

-- fara duplicate
SELECT DISTINCT /*sau UNIQUE*/ JOB_ID
FROM EMPLOYEES; -- 19 rezultate
                -- afiseaza din EMPLOYEES joburile distincte

SELECT JOB_ID
FROM JOBS; -- 19 rezultate UNICE deoarece JOB_ID este cheie primara in JOBS
           -- ceea ce inseamna ca nu se poate repeta
           -- In tabelul JOBS avem o lista cu toate joburie unice din baza de date
           
-- EX 6
SELECT LAST_NAME || ', ' || FIRST_NAME || ', ' || JOB_ID "Detalii Angajat", DEPARTMENT_ID
from EMPLOYEES;

-- EX 7
SELECT LAST_NAME || ' ' || FIRST_NAME AS "Nume si Prenume", salary "Salariu"
FROM EMPLOYEES
WHERE SALARY > 2850;

-- EX 8
SELECT * FROM EMPLOYEES;

SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 104; 

-- EX 9
-- salariul nu se afla in intervalul [14000, 24000]
SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY < 14000 OR SALARY > 24000; -- 103 angajati

-- salariul se afla in intervalul [14000, 24000]
SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY >= 14000 AND SALARY <= 24000; -- 4 angajati

-- NOT BETWEEN -> NU AFISEAZA CAPETELE INTERVALULUI
SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY NOT BETWEEN 14000 AND 24000; -- 103 angajati

-- BETWEEN -> AFISEAZA CAPETELE INTERVALULUI
SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 14000 AND 24000; -- 4 angajati

-- EX 10
SELECT LAST_NAME, JOB_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '02-FEB-1987' AND '01-MAY-1989'
ORDER BY HIRE_DATE; --implicit crescator

SELECT LAST_NAME, JOB_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '02-FEB-1987' AND '01-MAY-1989'
ORDER BY HIRE_DATE DESC;

-- METODE DE ORDONARE

-- ordonare folosind numarul coloanei din clauza SELECT
SELECT LAST_NAME, JOB_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '02-FEB-1987' AND '01-MAY-1989'
ORDER BY 3;

--ordonare folosind ALIASUL
SELECT LAST_NAME, JOB_ID, HIRE_DATE "Data Angajare"
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '02-FEB-1987' AND '01-MAY-1989'
ORDER BY "Data Angajare";

-- EX 11
SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (10, 30)
ORDER BY LAST_NAME, DEPARTMENT_ID;

SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10 OR DEPARTMENT_ID = 30
ORDER BY LAST_NAME, DEPARTMENT_ID;

-- EX 12
SELECT LAST_NAME "Angajat", SALARY "Salariu Lunar"
FROM EMPLOYEES
WHERE SALARY > 1500 AND DEPARTMENT_ID IN (10, 30);

-- EX 13
SELECT SYSDATE; -- EROARE -> nu respecta sintaxa (nu este FROM)

SELECT SYSDATE -- 107 rezultate
FROM EMPLOYEES;

DESC DUAL; -- pseudo-tabel

SELECT TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS')
FROM DUAL;

-- EX 14
-- Varianta 1
SELECT LAST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE LIKE '%87%';

-- Varianta 2
SELECT LAST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') = 1987;

-- EX 18
SELECT LAST_NAME
FROM EMPLOYEES
WHERE UPPER(LAST_NAME) LIKE '__A%';

SELECT LAST_NAME
FROM EMPLOYEES
WHERE LOWER(LAST_NAME) LIKE '__a%';

-- EX 19
SELECT LAST_NAME, DEPARTMENT_ID, MANAGER_ID
FROM EMPLOYEES
WHERE (UPPER(LAST_NAME) LIKE '%L%L' AND DEPARTMENT_ID = 30) OR MANAGER_ID = 102;