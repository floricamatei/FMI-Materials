

#SORTARI

#1.a) Se citeÈ™te o propoziÈ›ie cu cuvinte separate prin spaÈ›iu. SÄƒ se formeze o nouÄƒ propoziÈ›ie cu
#cuvintele din prima propoziÈ›ie care au lungime cel puÈ›in 2 ordonate descrescÄƒtor

p=input()
cuvinte=[x for x in p.split() if len(x)>=2]
rez=sorted(cuvinte,key=None,reverse=True)
print(rez)
#b) AceeaÈ™i cerinÈ›Äƒ ca la a), dar cu cuvintele ordonate descrescÄƒtor dupÄƒ lungime


p=input()
cuvinte=[x for x in p.split() if len(x)>=2]
rez=sorted(cuvinte,key=len,reverse=True)
print(rez)



#2. a) Se citesc un numÄƒr natural n È™i urmÄƒtoarele informaÈ›ii despre n persoane: cod de cel
#mult 3 cifre, nume (un singur nume), prenume (un singur prenume), vÃ¢rsta (informaÈ›ia despre
#o persoana este datÄƒ pe o linie). SÄƒ se creeze o listÄƒ de tupluri cu 3 elemente cu informaÈ›iile
#despre cele n persoane È™i sÄƒ se afiÈ™eze lista cu print.

n=int(input())
l=[]
for i in range(n):
    s=input()
    cod,nume,prenume,varsta=s.split()
    nume=nume+" "+prenume
    t=(int(cod),nume,int(varsta))
    l.append(t)
print(l)
#a) SÄƒ se afiÈ™eze persoanele ordonate dupÄƒ cod È™i, Ã®n caz de egalitate, dupÄƒ nume (pentru o
#persoanÄƒ se va afiÈ™a codul pe 4 caractere È™i numele)
l1=sorted(l,key=lambda t:(t[0],t[1]))
for x in l1:
    print(x[0],x[1])

#b) SÄƒ se afiÈ™eze persoanele ordonate dupÄƒ nume È™i, Ã®n caz de egalitate, dupÄƒ cod (pentru o
#persoanÄƒ se va afiÈ™a codul pe 4 caractere È™i numele)
l1=sorted(l,key=lambda t:(t[1],t[0]))
for x in l1:
    print(x[0],x[1])
#c) SÄƒ se afiÈ™eze vÃ¢rsta maximÄƒ a unei persoane din listÄƒ (folosind max(lista,key))
ma=max(l,key=lambda t:(t[2]))
print(ma[2])

---------------------------------------------------------------------------------------------

#MATRICE SI VECTORI


#1. Se citesc n, m È™i o matrice cu n linii si m coloane (numerele sunt date cÃ¢te unul pe linie).
#SÄƒ se ordoneze crescÄƒtor elementele de pe prima coloana prin interschimbÄƒri de linii È™i sÄƒ se
#afiÈ™eze matricea obÈ›inutÄƒ (fiecare element se va afiÈ™a pe 5 caractere)
n=int(input())
m=int(input())
a=[]
for i in range(n):
    l=[]
    for j in range(m):
        x=int(input())
        l.append(x)
    a.append(l)
l=sorted(a,key= lambda e:(e[0]))
for x in l:
    print(x)

#2. Se da un numÄƒr natural n>2. SÄƒ se afiÈ™eze primele n linii din triunghiul lui Pascal (daca c
#este numÄƒrul maxim de cifre ale unui numÄƒr din triunghi, toate numerele se vor afiÈ™a pe c+1
#caractere)
n=int(input())
p=1
#print(1)
for j in range(0,n+1):
    print(1,end=" ")
    for i in range(1,j+1):
        p=p*(j-i+1)//i
        print(p,end=" ")
    print()



#4. Se citesc m, n È™i o matrice cu m linii È™i n coloane, elementele unei linii fiind date pe o linie
#(elementele unei linii date pe o linie separate cu spaÈ›iu). SÄƒ se construiascÄƒ Ã®n memorie È™i sÄƒ
#se afiÈ™eze matricea transpusÄƒ.

n=int(input())
m=int(input())
a=[]
for i in range(n):
    s=input()
    l=[int(x) for x in s.split()]
    a.append(l)
at=[]
for i in range(m):
    b=[]
    for j in range(n):
        b.append(a[j][i])
    at.append(b)
print(at)



#5. Se citeÈ™te un numÄƒr natural N.
#a) SÄƒ se genereze È™i afiÈ™eze o matrice de dimensiune NxN, cu elementele de la 1 la N*N - Ã®n
#ordine crescÄƒtoare, de la stÃ¢nga la dreapta È™i de sus Ã®n jos.

n=int(input())
a=[[x+n*y+1 for x in range(n)]for y in range(n)]
print(a)
#b) Pentru a parcurge elementele matricei Ã®n spiralÄƒ, pornind din colÈ›ul din stÃ¢nga-sus (spre
#dreapta, Ã®n jos, spre stÃ¢nga, Ã®n sus, â€¦), sÄƒ se obÈ›inÄƒ Ã®ntÃ¢i o listÄƒ avÃ¢nd elemente de tip tuplu
#(linie, coloanÄƒ) care sÄƒ reprezinte poziÈ›iile care trebuie parcurse Ã®n aceastÄƒ spiralÄƒ.
l=[]
m=n-1
k=0
while k<m:
    i=k
    while i<m:
        t=(k,i)
        l.append(t)
        i=i+1
    i=k
    while i<m:
        t = (i, m)
        l.append(t)
        i = i + 1
    i=m
    while i>k:
        t = (m, i)
        l.append(t)
        i = i-1
    i=m
    while i>k:
        t = (i, k)
        l.append(t)
        i = i-1
    k=k+1
    m=m-1
if m==k:
    t=(k,k)
    l.append(t)
print(l)
#c) Folosind lista de tupluri de mai sus, sÄƒ se afiÈ™eze elementele din matrice aflate la acele
#poziÈ›ii.
for x in l:
    i=x[0]
    j=x[1]
    print(a[i][j],end=" ")




#6. Ciurul lui Eratostene. Se dÄƒ un numar natural n. SÄƒ se creeze o listÄƒ cu numerele prime
#mai mici sau egale cu n.

n=int(input())
import math
v=[0]*(n+1)
v[0]=1
v[1]=1
for i in range(2,int(math.sqrt(n))):
    if v[i]==0:
        for j in range(2,n//i):
            v[i*j]=1
l=[]
for i in range(2,n):
   if v[i]==0:
       l.append(i)
print(l)


#7. Se dau douÄƒ mulÈ›imi cu elementele ordonate crescÄƒtor (cÃ¢te una pe linie). SÄƒ se determine
#eficient reuniunea È™i intersecÈ›ia celor douÄƒ mulÈ›imi (fÄƒrÄƒ a folosi set).
s=input()
a=[int(x) for x in s.split()]
p=input()
b=[int(x) for x in p.split()]
t=[]
l=[]
i=0
j=0
n=len(a)
m=len(b)
while i<n and j<m:
    if a[i]<b[j]:
        l.append(a[i])
        i = i + 1
    else:
        if a[i]==b[j]:
            l.append(a[i])
            t.append(a[i])
            i = i + 1
            j = j + 1
        else:
            l.append(b[j])
            j = j + 1
while i<n:
    l.append(a[i])
    i = i + 1
while j<m:
    l.append(b[j])
    j = j + 1
print(l)
print(t)



#8. Se citesc: un numÄƒr natural n È™i un È™ir de n numere naturale.
#a) SÄƒ se afiÈ™eze toate perechile distincte de elemente din È™ir cu suma 0 (2-SUM)
n=int(input())
s=input()
l=[int(x) for x in s.split()]
print(l)
l=sorted(l,key=None)

for i in range(n):
    for j in range(i+1,n):
        if l[i]+l[j]==0:
            print(l[i],l[j])
#b) SÄƒ se afiÈ™eze toate tripletele de elemente din È™ir cu suma 0
for i in range(n):
    for j in range(n):
        for k in range(n):
            if l[i] + l[j] + l[k] == 0:
                print(l[i], l[j], l[k])

#c) SÄƒ se afiÈ™eze toate tripletele distincte de elemente din È™ir cu suma 0 (3-SUM)
for i in range(n):
    for j in range(i+1,n):
        for k in range(j+1,n):
            if l[i] + l[j] + l[k] == 0:
                print(l[i], l[j], l[k])



-------------------------------------------------------------------------------------------

#SIRURI DE CARACTERE

#1. Cifrul lui Cezar
#a) SÄƒ se creeze Ã®n memorie o listÄƒ cu literele mici ale alfabetului È™i un cuvÃ¢nt avÃ¢nd ca litere
#toate literele mici ale alfabetului

l=[]
cuv=""
for x in range(26):
    c=chr(ord('a')+x)
    cuv=cuv+c
    l.append(c)
print(l)
print(cuv)


#b) Se citeÈ™te un text È™i un numÄƒr natural k. SÄƒ se afiÈ™eze textul cifrat cu cifrul lui Cezar, prin
#care fiecare literÄƒ (!doar literele) este Ã®nlocuitÄƒ cu litera aflatÄƒ peste ğ‘˜ poziÈ›ii la dreapta Ã®n
#alfabet Ã®n mod circular (valoarea ğ‘˜ reprezintÄƒ cheia secretÄƒ comunÄƒ pe care trebuie sÄƒ o
#cunoascÄƒ atÃ¢t expeditorul, cÃ¢t È™i destinatarul mesajului criptat).

p=input()
k=int(input())
rez=""
for i in range(0,len(p)):
    if p[i].isalpha():
        #print(chr((ord(p[i])+k)-(ord('z')-ord('a'))))
        if ord(p[i])+k>=ord('z'):
            rez=rez+chr((ord(p[i])+k)-(ord('z')-ord('a')+1))
        else:
            rez=rez+chr((ord(p[i])+k))
    else:
        rez=rez+p[i]
print(rez)


#b) Se citeÈ™te un numÄƒr natural k È™i text criptat cu cifrul lui Cezar cu cheia k. SÄƒ se afiÈ™eze
#textul decriptat

p=input()
k=int(input())
rez=""
for i in range(0,len(p)):
    if p[i].isalpha():
        #print(chr((ord(p[i])+k)-(ord('z')-ord('a'))))
        if ord(p[i])-k<ord('a'):
            rez=rez+chr((ord(p[i])-k)-ord('a')+(ord('z')+1))
        else:
            rez=rez+chr((ord(p[i])-k))
    else:
        rez=rez+p[i]
print(rez)


#2. Se dÄƒ o propoziÈ›ie care conÈ›ine cuvinte separate prin separatorii uzuali ( ,.;:). O parte din
#cuvinte reprezintÄƒ numere naturale. SÄƒ se determine media aritmeticÄƒ a cuvintelor din È™ir care
#sunt numere. Mai exact, rezultatul va fi un È™ir de forma: â€œ(nr1+...nr_k)/n=mediaâ€, unde
#nr1,...,nrk sunt numerele care apar Ã®n È™ir È™i media este afiÈ™atÄƒ cu 2 zecimale.

s=input()
l=[]
n=len(s)
i=0
sum=0
while i<n:
    if s[i].isdigit():
        nr=0
        j=i
        while j<n and s[j].isdigit():
            nr = nr * 10 + ord(s[i])-ord('0')
            j=j+1
        l.append(s[i:j])
        sum=sum+nr
        i=j
    else:
        i=i+1
numere=l
print(numere)
n=len(l)
print("({})/{} = {:.2f}".format("+".join(numere),n,sum/n))



#3. Se citesc doua cuvinte formate doar din litere mici. SÄƒ se verifice dacÄƒ sunt anagrame
a=input()
b=input()
c=sorted(a,key=None)
d=sorted(b,key=None)
if c == d:
    print(True)
else:
    print(False)


# Fiind dat un astfel de text Ã®n limba pÄƒsÄƒreascÄƒ, se poate obÈ›ine textul original?
#DacÄƒ da, scrieÈ›i un program care primind un text Ã®n limba pÄƒsÄƒreascÄƒ construieÈ™te Ã®n memorie
#È™i afiÈ™eazÄƒ textul iniÈ›ial.

s=input()
rez=""
voc="aeiou"
l=len(s)
i=0
while i < l:
    if i>0 and s[i]=='p' and s[i-1]==s[i+1] and s[i-1] in voc:
        i=i+2
    else:
        rez=rez+s[i]
        i=i+1
print(rez)

